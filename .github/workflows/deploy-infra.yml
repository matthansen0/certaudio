name: Deploy Infrastructure

concurrency:
  group: deploy-infra-${{ github.ref }}
  cancel-in-progress: true

on:
  # Triggers on infra changes, SWA/Functions code changes, or manual dispatch
  push:
    branches: [main]
    paths:
      - 'infra/**'
      - 'src/web/**'
      - 'src/functions/**'
      - '.github/workflows/deploy-infra.yml'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  # Primary location - centralus supports all required services and has better capacity:
  # Static Web Apps, Speech, Search, Cosmos DB, Storage, Functions
  LOCATION: 'centralus'
  # OpenAI location - separate region since centralus doesn't support GPT-4o GlobalStandard
  OPENAI_LOCATION: 'eastus'
  # Controls the resource-name suffix used by Bicep.
  # - Set secret AZURE_UNIQUE_SUFFIX to pin deployments to a single stable environment (recommended).
  # - If unset, falls back to github.run_id, which avoids name collisions but creates new resources every run.
  UNIQUE_SUFFIX: ${{ secrets.AZURE_UNIQUE_SUFFIX || github.run_id }}

# =============================================================================
# REQUIRED SECRETS (configure in GitHub Settings > Secrets > Actions):
# - AZURE_CLIENT_ID:        Service principal/app registration client ID
# - AZURE_TENANT_ID:        Azure AD tenant ID  
# - AZURE_SUBSCRIPTION_ID:  Azure subscription ID
# - AZURE_RESOURCE_GROUP:   Resource group name (e.g., rg-certaudio-dev)
# OPTIONAL:
# - AZURE_UNIQUE_SUFFIX:    Pin resource name suffix to avoid creating new resources each run
# =============================================================================

jobs:
  check-secrets:
    name: Validate Required Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Check required secrets are configured
        run: |
          missing=""
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then missing="$missing AZURE_CLIENT_ID"; fi
          if [ -z "${{ secrets.AZURE_TENANT_ID }}" ]; then missing="$missing AZURE_TENANT_ID"; fi
          if [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then missing="$missing AZURE_SUBSCRIPTION_ID"; fi
          if [ -z "${{ secrets.AZURE_RESOURCE_GROUP }}" ]; then missing="$missing AZURE_RESOURCE_GROUP"; fi
          if [ -n "$missing" ]; then
            echo "::error::Missing required secrets:$missing"
            echo ""
            echo "Configure these secrets in GitHub: Settings > Secrets and variables > Actions"
            echo "See README.md for setup instructions."
            exit 1
          fi
          echo "✅ All required secrets are configured"

  validate:
    name: Validate Bicep
    needs: check-secrets
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Bicep template
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail

            accessToken=$(az account get-access-token \
              --resource https://management.azure.com \
              --query accessToken -o tsv)
            export ACCESS_TOKEN="$accessToken"

            automationPrincipalId=$(python3 - <<'PY'
            import os, json, base64
            token = os.environ.get('ACCESS_TOKEN', '')
            parts = token.split('.')
            if len(parts) < 2:
              print('')
              raise SystemExit(0)
            payload = parts[1]
            payload += '=' * (-len(payload) % 4)
            data = base64.urlsafe_b64decode(payload.encode('utf-8')).decode('utf-8')
            claims = json.loads(data)
            print(claims.get('oid') or claims.get('objectId') or '')
            PY
            )

            if [[ -z "$automationPrincipalId" ]]; then
              echo "::warning::Could not determine automation principal objectId from access token; Cosmos SQL RBAC for automation will not be applied."
            else
              echo "Automation principal objectId: $automationPrincipalId"
            fi

            deploymentName="certaudio-${{ github.run_id }}-${{ github.run_attempt }}"

            az deployment group validate \
              --name "$deploymentName" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --template-file ./infra/main.bicep \
              --parameters \
                uniqueSuffix=$UNIQUE_SUFFIX \
                location=$LOCATION \
                openAiLocation=$OPENAI_LOCATION \
                automationPrincipalId=$automationPrincipalId

  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: validate
    # NOTE: We don't pass app names as job outputs because GitHub Actions masks them
    # (they contain the UNIQUE_SUFFIX secret). Downstream jobs construct names directly.
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Bicep template
        uses: azure/cli@v2
        env:
          DEPLOYMENT_NAME: certaudio-${{ github.run_id }}-${{ github.run_attempt }}
        with:
          inlineScript: |
            set -euo pipefail

            accessToken=$(az account get-access-token \
              --resource https://management.azure.com \
              --query accessToken -o tsv)
            export ACCESS_TOKEN="$accessToken"

            automationPrincipalId=$(python3 - <<'PY'
            import os, json, base64
            token = os.environ.get('ACCESS_TOKEN', '')
            parts = token.split('.')
            if len(parts) < 2:
              print('')
              raise SystemExit(0)
            payload = parts[1]
            payload += '=' * (-len(payload) % 4)
            data = base64.urlsafe_b64decode(payload.encode('utf-8')).decode('utf-8')
            claims = json.loads(data)
            print(claims.get('oid') or claims.get('objectId') or '')
            PY
            )

            if [[ -z "$automationPrincipalId" ]]; then
              echo "::warning::Could not determine automation principal objectId from access token; Cosmos SQL RBAC for automation will not be applied."
            else
              echo "Automation principal objectId: $automationPrincipalId"
            fi

            # Determine enableStudyPartner value
            # For workflow_dispatch, use the input; for push events, use default (false)
            if [[ "${ENABLE_STUDY_PARTNER:-false}" == "true" ]]; then
              enableStudyPartner="true"
            else
              enableStudyPartner="false"
            fi
            echo "Study Partner enabled: $enableStudyPartner"

            # Run deployment
            if ! az deployment group create \
              --name "$DEPLOYMENT_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --template-file ./infra/main.bicep \
              --parameters \
                uniqueSuffix=$UNIQUE_SUFFIX \
                location=$LOCATION \
                openAiLocation=$OPENAI_LOCATION \
                automationPrincipalId=$automationPrincipalId \
                enableStudyPartner=$enableStudyPartner \
              --only-show-errors; then
              echo "::group::Deployment error (properties.error)"
              az deployment group show \
                --name "$DEPLOYMENT_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --query properties.error \
                -o jsonc || true
              echo "::endgroup::"

              echo "::group::Failed deployment operations"
              az deployment operation group list \
                --name "$DEPLOYMENT_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --query "[?properties.provisioningState=='Failed'].{resource:properties.targetResource.resourceName, type:properties.targetResource.resourceType, state:properties.provisioningState, message:properties.statusMessage}" \
                -o table || true
              echo "::endgroup::"

              exit 1
            fi

      - name: Assign role permissions to Functions managed identity
        uses: azure/cli@v2
        env:
          DEPLOYMENT_NAME: certaudio-${{ github.run_id }}-${{ github.run_attempt }}
        with:
          inlineScript: |
            set -euo pipefail
            
            # Get resource names from deployment outputs
            FUNC_APP_NAME=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.functionsAppName.value" -o tsv)
            FUNC_STORAGE_NAME=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.funcStorageAccountName.value" -o tsv)
            DATA_STORAGE_NAME=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.storageAccountName.value" -o tsv)
            COSMOS_NAME=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.cosmosDbAccountName.value" -o tsv)
            COSMOS_DB_NAME=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.cosmosDbDatabaseName.value" -o tsv)
            
            # Get Function App managed identity principal ID
            PRINCIPAL_ID=$(az functionapp identity show --name "$FUNC_APP_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query principalId -o tsv)
            echo "Function App: $FUNC_APP_NAME"
            echo "Principal ID: $PRINCIPAL_ID"
            
            # Role definition IDs (built-in roles)
            BLOB_CONTRIBUTOR="ba92f5b4-2d11-453d-a403-e96b0029c9fe"
            QUEUE_CONTRIBUTOR="974c5e8b-45b9-4653-ba55-5f855dd0fb88"
            TABLE_CONTRIBUTOR="0a9a7e1f-b9d0-4cc4-a60d-0319b160aaa3"
            BLOB_READER="2a2b9908-6ea1-4ae2-8e65-a410df84e7d1"
            
            # Helper function: assign role if not already assigned
            assign_role() {
              local scope="$1"
              local role_id="$2"
              local role_name="$3"
              
              existing=$(az role assignment list --scope "$scope" --assignee "$PRINCIPAL_ID" --role "$role_id" --query "[].id" -o tsv 2>/dev/null || echo "")
              if [[ -n "$existing" ]]; then
                echo "✓ $role_name already assigned"
              else
                echo "→ Assigning $role_name..."
                az role assignment create --scope "$scope" --assignee-object-id "$PRINCIPAL_ID" --assignee-principal-type ServicePrincipal --role "$role_id" -o none
                echo "✓ $role_name assigned"
              fi
            }
            
            # Functions storage account: Blob, Queue, Table Contributor
            FUNC_STORAGE_SCOPE="/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.Storage/storageAccounts/$FUNC_STORAGE_NAME"
            echo ""
            echo "=== Functions Storage: $FUNC_STORAGE_NAME ==="
            assign_role "$FUNC_STORAGE_SCOPE" "$BLOB_CONTRIBUTOR" "Storage Blob Data Contributor"
            assign_role "$FUNC_STORAGE_SCOPE" "$QUEUE_CONTRIBUTOR" "Storage Queue Data Contributor"
            assign_role "$FUNC_STORAGE_SCOPE" "$TABLE_CONTRIBUTOR" "Storage Table Data Contributor"
            
            # Data storage account: Blob Reader
            DATA_STORAGE_SCOPE="/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.Storage/storageAccounts/$DATA_STORAGE_NAME"
            echo ""
            echo "=== Data Storage: $DATA_STORAGE_NAME ==="
            assign_role "$DATA_STORAGE_SCOPE" "$BLOB_READER" "Storage Blob Data Reader"
            assign_role "$DATA_STORAGE_SCOPE" "$BLOB_DELEGATOR" "Storage Blob Delegator"
            
            # Azure OpenAI: Cognitive Services OpenAI User (for Study Partner chat)
            OPENAI_USER="5e0bd9bd-7b93-4f28-af87-19fc36ad61bd"
            OPENAI_NAME=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.openAiName.value" -o tsv)
            OPENAI_SCOPE="/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.CognitiveServices/accounts/$OPENAI_NAME"
            echo ""
            echo "=== Azure OpenAI: $OPENAI_NAME ==="
            assign_role "$OPENAI_SCOPE" "$OPENAI_USER" "Cognitive Services OpenAI User"
            
            # AI Search: Search Index Data Reader (for Study Partner RAG - only when enabled)
            SEARCH_NAME=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.searchName.value" -o tsv 2>/dev/null || echo "")
            if [[ -n "$SEARCH_NAME" ]]; then
              SEARCH_INDEX_READER="1407120a-92aa-4202-b7e9-c0e197c71c8f"
              SEARCH_SCOPE="/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.Search/searchServices/$SEARCH_NAME"
              echo ""
              echo "=== AI Search: $SEARCH_NAME ==="
              assign_role "$SEARCH_SCOPE" "$SEARCH_INDEX_READER" "Search Index Data Reader"
            else
              echo ""
              echo "=== AI Search: Not deployed (Study Partner disabled) ==="
            fi
            
            # Cosmos DB: SQL Data Contributor
            echo ""
            echo "=== Cosmos DB: $COSMOS_NAME ==="
            COSMOS_ROLE_DEF="/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.DocumentDB/databaseAccounts/$COSMOS_NAME/sqlRoleDefinitions/00000000-0000-0000-0000-000000000002"
            COSMOS_SCOPE="/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.DocumentDB/databaseAccounts/$COSMOS_NAME/dbs/$COSMOS_DB_NAME"
            
            # Check if Cosmos role assignment exists
            existing_cosmos=$(az cosmosdb sql role assignment list \
              --account-name "$COSMOS_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --query "[?principalId=='$PRINCIPAL_ID'].id" -o tsv 2>/dev/null || echo "")
            
            if [[ -n "$existing_cosmos" ]]; then
              echo "✓ Cosmos DB SQL Data Contributor already assigned"
            else
              echo "→ Assigning Cosmos DB SQL Data Contributor..."
              az cosmosdb sql role assignment create \
                --account-name "$COSMOS_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --role-definition-id "$COSMOS_ROLE_DEF" \
                --principal-id "$PRINCIPAL_ID" \
                --scope "$COSMOS_SCOPE" \
                -o none
              echo "✓ Cosmos DB SQL Data Contributor assigned"
            fi
            
            echo ""
            echo "=== Role assignment complete ==="

      - name: Get deployment outputs
        id: outputs
        env:
          DEPLOYMENT_NAME: certaudio-${{ github.run_id }}-${{ github.run_attempt }}
        run: |
          set -euo pipefail
          
          staticWebAppUrl=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.staticWebAppUrl.value" -o tsv 2>/dev/null || echo "")
          staticWebAppName=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.staticWebAppName.value" -o tsv 2>/dev/null || echo "")
          functionsAppName=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.functionsAppName.value" -o tsv 2>/dev/null || echo "")
          storageAccountName=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.storageAccountName.value" -o tsv 2>/dev/null || echo "")
          cosmosDbAccountName=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query "properties.outputs.cosmosDbAccountName.value" -o tsv 2>/dev/null || echo "")

          echo "Resolved output names: functionsAppName='$functionsAppName', staticWebAppName='$staticWebAppName'"
          if [[ -z "$functionsAppName" || -z "$staticWebAppName" ]]; then
            echo "::error::Unable to resolve deployment outputs for Functions/SWA. Aborting before downstream deploy steps."
            exit 1
          fi

          # Write to step summary (no longer passing as job outputs due to secret masking)
          echo "## Deployment Complete! :rocket:" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Resource | Value |" >> "$GITHUB_STEP_SUMMARY"
          echo "|----------|-------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Static Web App URL | $staticWebAppUrl |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Functions App | $functionsAppName |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Storage Account | $storageAccountName |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Cosmos DB | $cosmosDbAccountName |" >> "$GITHUB_STEP_SUMMARY"

  deploy-functions:
    name: Deploy Functions App
    runs-on: ubuntu-latest
    needs: deploy  # Wait for infra to be deployed
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # NOTE: We do NOT install dependencies locally. The azure-functions runtime is
      # compiled against an older glibc than the GitHub runner. By leaving requirements.txt
      # in the zip and enabling SCM_DO_BUILD_DURING_DEPLOYMENT=true (in Bicep), the Function App
      # performs a "remote build" and installs packages in a compatible environment.
      - name: Zip Functions package (source only, remote build)
        run: |
          cd src/functions
          zip -r "$GITHUB_WORKSPACE/functions.zip" . -x ".python_packages/*"

      - name: Deploy to Azure Functions (zip deploy with remote build)
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail
            # Construct name directly (can't use job outputs - they contain secrets and get masked)
            FUNCTIONS_APP_NAME="certaudio-dev-func-$UNIQUE_SUFFIX"
            echo "Deploying to Functions App: $FUNCTIONS_APP_NAME (remote build enabled)"
            # --build-remote ensures pip install runs on Azure, avoiding glibc mismatch
            # Timeout: 600s (10 min) - remote builds compile numpy/scipy, can take 7-10 min
            az functionapp deployment source config-zip \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$FUNCTIONS_APP_NAME" \
              --src "functions.zip" \
              --build-remote true \
              --timeout 600

      - name: Disable App Service authentication (EasyAuth)
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail

            FUNCTIONS_APP_NAME="certaudio-dev-func-$UNIQUE_SUFFIX"
            echo "Disabling App Service auth (v2) for: $FUNCTIONS_APP_NAME"

            siteId=$(az functionapp show \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$FUNCTIONS_APP_NAME" \
              --query id -o tsv)

            uri="https://management.azure.com${siteId}/config/authsettingsV2?api-version=2022-03-01"

            # Bicep deploys authsettingsV2 with enabled=false, but SWA backend linking
            # or other processes can re-enable it. Force-disable here.
            az rest \
              --method put \
              --uri "$uri" \
              --body '{
                "properties": {
                  "platform": { "enabled": false },
                  "globalValidation": {
                    "requireAuthentication": false,
                    "unauthenticatedClientAction": "AllowAnonymous"
                  }
                }
              }'

            echo "Restarting Function App to apply auth changes..."
            az functionapp restart \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$FUNCTIONS_APP_NAME" \
              --only-show-errors
            sleep 20

      - name: Smoke test Functions directly
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail

            FUNCTIONS_APP_NAME="certaudio-dev-func-$UNIQUE_SUFFIX"
            hostname=$(az functionapp show \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$FUNCTIONS_APP_NAME" \
              --query defaultHostName -o tsv)

            url="https://$hostname/api/healthz"
            echo "Smoke test: $url"

            maxAttempts=15
            attempt=1
            lastHttpCode=""
            while [[ $attempt -le $maxAttempts ]]; do
              echo "Attempt $attempt/$maxAttempts: GET $url"
              httpCode=$(curl -sS -D /tmp/functions_headers.txt -o /tmp/functions_body.txt -w "%{http_code}" "$url" || true)
              lastHttpCode="$httpCode"
              echo "HTTP $httpCode"

              # 200 means healthy - success!
              if [[ "$httpCode" == "200" ]]; then
                echo "✅ Functions healthz OK (HTTP $httpCode)"
                exit 0
              fi

              # All other codes (404, 401, 403, 000) - retry
              echo "Waiting 10s before retry..."
              sleep 10
              ((attempt++))
            done

            # Final failure diagnostics
            echo "::error::Functions /api/healthz did not return HTTP 200 after $maxAttempts attempts (last: HTTP $lastHttpCode)."

            echo "::group::Functions response headers"
            head -60 /tmp/functions_headers.txt || true
            echo "::endgroup::"

            echo "::group::Functions response body (truncated)"
            head -200 /tmp/functions_body.txt || true
            echo "::endgroup::"

            if [[ "$lastHttpCode" == "401" || "$lastHttpCode" == "403" ]]; then
              # Disambiguate: function-key auth vs App Service auth.
              masterKey=$(az functionapp keys list \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --name "$FUNCTIONS_APP_NAME" \
                --query masterKey -o tsv 2>/dev/null || true)

              if [[ -n "$masterKey" ]]; then
                echo "::add-mask::$masterKey"
                echo "Retrying once with x-functions-key header (diagnostic)..."
                httpCodeKeyed=$(curl -sS -o /tmp/functions_body_keyed.txt -w "%{http_code}" -H "x-functions-key: $masterKey" "$url" || true)
                echo "HTTP (with key) $httpCodeKeyed"

                if [[ "$httpCodeKeyed" == "200" ]]; then
                  echo "::error::Functions responded only when a host key was provided. This indicates the HTTP trigger is not anonymous."
                fi
              fi
            fi

            exit 1

  deploy-static-web-app:
    name: Deploy Static Web App
    runs-on: ubuntu-latest
    needs: deploy  # Wait for infra to be deployed
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Static Web App deployment token
        id: swaToken
        run: |
          set -euo pipefail
          # Construct name directly (can't use job outputs - they contain secrets and get masked)
          SWA_NAME="certaudio-dev-swa-$UNIQUE_SUFFIX"
          echo "Getting deployment token for SWA: $SWA_NAME"
          token=$(az staticwebapp secrets list \
            --name "$SWA_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query properties.apiKey -o tsv)
          echo "token=$token" >> "$GITHUB_OUTPUT"

      - name: Deploy Static Web App
        uses: azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ steps.swaToken.outputs.token }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: 'upload'
          app_location: 'src/web'
          api_location: ''
          output_location: ''
          skip_api_build: true

  link-swa-backend:
    name: Link SWA API Backend (Functions)
    runs-on: ubuntu-latest
    needs:
      - deploy-functions
      - deploy-static-web-app
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Link Functions backend to SWA
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail

            SWA_NAME="certaudio-dev-swa-$UNIQUE_SUFFIX"
            FUNCTIONS_APP_NAME="certaudio-dev-func-$UNIQUE_SUFFIX"

            echo "Static Web App: $SWA_NAME"
            echo "Functions App:  $FUNCTIONS_APP_NAME"

            backendResourceId=$(az functionapp show \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$FUNCTIONS_APP_NAME" \
              --query id -o tsv)

            echo "Backend resource id: $backendResourceId"

            echo "Validating backend..."
            az staticwebapp backends validate \
              --name "$SWA_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --backend-resource-id "$backendResourceId" \
              --backend-region "$LOCATION" \
              --environment-name default \
              --only-show-errors

            currentBackendId=$(az staticwebapp backends show \
              --name "$SWA_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --environment-name default \
              --query backendResourceId -o tsv 2>/dev/null || true)

            if [[ -n "$currentBackendId" && "$currentBackendId" != "$backendResourceId" ]]; then
              echo "A different backend is already linked; unlinking first."
              az staticwebapp backends unlink \
                --name "$SWA_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --environment-name default \
                --remove-backend-auth \
                --only-show-errors
              currentBackendId=""
            fi

            if [[ "$currentBackendId" != "$backendResourceId" ]]; then
              echo "Linking backend..."
              az staticwebapp backends link \
                --name "$SWA_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --backend-resource-id "$backendResourceId" \
                --backend-region "$LOCATION" \
                --environment-name default \
                --only-show-errors
            else
              echo "Backend already linked; nothing to do."
            fi

            echo "Backend status:"
            az staticwebapp backends show \
              --name "$SWA_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --environment-name default \
              -o jsonc || true

            # NOTE: SWA backend linking re-enables EasyAuth on the Functions app.
            # We must disable it AFTER the link, not before.
            echo "Disabling EasyAuth on Functions app (SWA backend link re-enables it)..."
            siteId=$(az functionapp show \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$FUNCTIONS_APP_NAME" \
              --query id -o tsv)

            authUri="https://management.azure.com${siteId}/config/authsettingsV2?api-version=2022-03-01"

            az rest \
              --method put \
              --uri "$authUri" \
              --body '{
                "properties": {
                  "platform": { "enabled": false },
                  "globalValidation": {
                    "requireAuthentication": false,
                    "unauthenticatedClientAction": "AllowAnonymous"
                  }
                }
              }'

            echo "Restarting Functions app to apply auth changes..."
            az functionapp restart \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --name "$FUNCTIONS_APP_NAME" \
              --only-show-errors

            # Wait for restart to propagate
            sleep 30

            # Smoke test with retry - backend link can take time to propagate
            echo "Smoke test: calling SWA /api/healthz (with retry)"
            swaHostname=$(az staticwebapp show \
              --name "$SWA_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --query defaultHostname -o tsv)
            url="https://$swaHostname/api/healthz"
            
            maxAttempts=20
            attempt=1
            while [[ $attempt -le $maxAttempts ]]; do
              echo "Attempt $attempt/$maxAttempts: GET $url"
              httpCode=$(curl -sS -D /tmp/swa_headers.txt -o /tmp/swa_body.txt -w "%{http_code}" "$url" || true)
              echo "HTTP $httpCode"

              if [[ $attempt -eq 1 ]]; then
                echo "::group::SWA response headers (attempt 1)"
                head -60 /tmp/swa_headers.txt || true
                echo "::endgroup::"
              fi
              
              if [[ "$httpCode" == "200" ]]; then
                echo "✅ SWA /api/healthz OK (HTTP $httpCode)"
                break
              fi

              if [[ "$httpCode" == "401" || "$httpCode" == "403" ]]; then
                echo "::group::SWA response headers (auth failure)"
                head -60 /tmp/swa_headers.txt || true
                echo "::endgroup::"
                echo "::group::SWA response body (auth failure, truncated)"
                head -200 /tmp/swa_body.txt || true
                echo "::endgroup::"
                echo "::error::SWA /api/healthz returned HTTP $httpCode (backend auth is blocking requests)."
                exit 1
              fi
              
              if [[ $attempt -eq $maxAttempts ]]; then
                echo "::group::SWA response headers (last attempt)"
                head -60 /tmp/swa_headers.txt || true
                echo "::endgroup::"

                echo "::group::SWA response body (last attempt, truncated)"
                head -200 /tmp/swa_body.txt || true
                echo "::endgroup::"
                echo "::error::SWA /api/healthz did not return HTTP 200 after $maxAttempts attempts."
                exit 1
              fi
              
              echo "Backend link not yet propagated, waiting 15s..."
              sleep 15
              ((attempt++))
            done
